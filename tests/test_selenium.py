import os
import socket
import subprocess
import sys
import time
import unittest
from contextlib import suppress

from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.ui import WebDriverWait
from webdriver_manager.chrome import ChromeDriverManager

BASE_URL = os.getenv("TEST_BASE_URL", "http://127.0.0.1:5001")
PORT = int(os.getenv("TEST_PORT", "5001"))
TEST_USER = {"username": "testuser", "password": "123456"}

LOGIN_USERNAME_INP = "#username"
LOGIN_PASSWORD_INP = "#password"
LOGIN_SUBMIT_BTN = "input[type='submit'], button[type='submit']"

CTA_DASHBOARD = "a.btn-success[href='/data/create_diary']"
FAB_BTN = ".fab-btn"
TITLE_SELECTOR = "#diaryTitle"
CONTENT_SELECTOR = "#diaryContent"
SAVE_BTN_SELECTOR = "button[type='submit'], i.bi-check-lg"
CARD_TITLE_SELECTOR = ".card-title"


def wait_port(host: str, port: int, timeout: int = 60) -> None:
    """Block the caller until *host:port* is ready to accept connections."""
    start = time.time()
    while time.time() - start < timeout:
        with suppress(OSError):
            with socket.create_connection((host, port), 1):
                return
        time.sleep(0.5)
    raise RuntimeError(f"Server on {host}:{port} did not start within {timeout}s")


class MoodDiaryE2E(unittest.TestCase):
    """End-to-end tests that cover the principal user workflows."""

    @classmethod
    def setUpClass(cls) -> None:
        cls.server = subprocess.Popen([sys.executable, "run.py"])
        wait_port("127.0.0.1", PORT)

        chrome_opts = webdriver.ChromeOptions()
        chrome_opts.add_argument("--headless=new")
        chrome_opts.add_argument("--window-size=1400,900")
        chrome_opts.add_argument("--disable-gpu")
        chrome_opts.add_experimental_option("excludeSwitches", ["enable-logging"])

        cls.driver = webdriver.Chrome(
            service=Service(ChromeDriverManager().install()),
            options=chrome_opts,
        )

    @classmethod
    def tearDownClass(cls) -> None:
        with suppress(Exception):
            cls.driver.quit()
        with suppress(Exception):
            cls.server.terminate()
            cls.server.wait(timeout=5)

    # utility -------------------------------------------------------

    def wait(self, condition, timeout: int = 12):
        """Convenience wrapper around WebDriverWait."""
        return WebDriverWait(self.driver, timeout).until(condition)

    def login(self) -> None:
        """Authenticate through the UI and open the personal dashboard."""
        self.driver.delete_all_cookies()
        with suppress(Exception):
            self.driver.get(f"{BASE_URL}/auth/logout")

        self.driver.get(f"{BASE_URL}/auth/login")
        self.wait(EC.presence_of_element_located((By.CSS_SELECTOR, LOGIN_USERNAME_INP))).send_keys(
            TEST_USER["username"]
        )
        self.driver.find_element(By.CSS_SELECTOR, LOGIN_PASSWORD_INP).send_keys(
            TEST_USER["password"]
        )
        self.driver.find_element(By.CSS_SELECTOR, LOGIN_SUBMIT_BTN).click()

        self.wait(lambda d: not d.find_elements(By.CSS_SELECTOR, ".swal2-container"))
        self.driver.get(f"{BASE_URL}/home")

    def open_create_diary(self) -> None:
        """Open the diary-creation form from the dashboard."""
        try:
            self.wait(
                EC.element_to_be_clickable((By.CSS_SELECTOR, CTA_DASHBOARD)), timeout=4
            ).click()
        except Exception:
            self.wait(EC.element_to_be_clickable((By.CSS_SELECTOR, FAB_BTN))).click()

    # tests ---------------------------------------------------------

    def test_homepage_smoke(self):
        """The landing page loads and contains the expected heading."""
        self.driver.get(BASE_URL)
        heading = self.wait(EC.visibility_of_element_located((By.TAG_NAME, "h1")))
        self.assertRegex(heading.text, r"(Mood|Track)")

    def test_login_and_logout_flow(self):
        """Successful log-in followed by log-out returns the user to public state."""
        self.login()
        self.wait(EC.element_to_be_clickable((By.LINK_TEXT, "Log Out"))).click()
        self.wait(EC.visibility_of_element_located((By.LINK_TEXT, "Log In")))

    def test_create_diary_card(self):
        """After creating a diary entry, its card appears on the dashboard."""
        self.login()
        self.open_create_diary()

        title = f"E2E-entry {int(time.time())}"
        self.wait(EC.presence_of_element_located((By.CSS_SELECTOR, TITLE_SELECTOR))).send_keys(
            title
        )
        self.driver.find_element(By.CSS_SELECTOR, CONTENT_SELECTOR).send_keys(
            "Content generated by automated test."
        )
        self.driver.find_element(By.CSS_SELECTOR, SAVE_BTN_SELECTOR).click()

        self.wait(EC.visibility_of_element_located((By.CSS_SELECTOR, CARD_TITLE_SELECTOR)))
        titles = [
            el.text.strip()
            for el in self.driver.find_elements(By.CSS_SELECTOR, CARD_TITLE_SELECTOR)
        ]
        self.assertIn(title, titles)


if __name__ == "__main__":
    unittest.main(verbosity=2)